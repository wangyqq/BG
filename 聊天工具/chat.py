# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'chat.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from threading import Thread
import socket

from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        self.pc = None  # 预设这个变量
        self.statusBar = QtWidgets.QStatusBar()  # 状态栏


        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setGeometry(QtCore.QRect(60, 50, 421, 331))
        self.textBrowser.setObjectName("textBrowser")
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(60, 430, 421, 51))
        self.lineEdit.setText("")
        self.lineEdit.setObjectName("lineEdit")

        self.checkBox = QtWidgets.QRadioButton(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(530, 400, 105, 22))
        self.checkBox.setChecked(True)
        self.checkBox.setObjectName("checkBox")
        self.checkBox.toggled.connect(self.radiobtnChange)
        self.checkBox_2 = QtWidgets.QRadioButton(self.centralwidget)
        self.checkBox_2.setGeometry(QtCore.QRect(650, 400, 105, 22))
        self.checkBox_2.setObjectName("checkBox_2")

        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(520, 440, 235, 36))
        self.widget.setObjectName("widget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.widget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")

        # 建立服务器
        self.pushButton_4 = QtWidgets.QPushButton(self.widget)
        self.pushButton_4.setObjectName("pushButton_4")
        self.horizontalLayout.addWidget(self.pushButton_4)
        self.pushButton_4.clicked.connect(self.setServer)
        # 连接服务器
        self.pushButton_3 = QtWidgets.QPushButton(self.widget)
        self.pushButton_3.setObjectName("pushButton_3")
        self.horizontalLayout.addWidget(self.pushButton_3)
        self.pushButton_3.clicked.connect(self.setClient)
        self.pushButton_3.setEnabled(False)

        self.widget1 = QtWidgets.QWidget(self.centralwidget)
        self.widget1.setGeometry(QtCore.QRect(140, 500, 235, 36))
        self.widget1.setObjectName("widget1")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget1)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")

        self.pushButton = QtWidgets.QPushButton(self.widget1) # 发送
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.sendInfo)
        self.horizontalLayout_2.addWidget(self.pushButton)

        self.pushButton_2 = QtWidgets.QPushButton(self.widget1) # 选择图片
        self.pushButton_2.setObjectName("pushButton_2")
        self.horizontalLayout_2.addWidget(self.pushButton_2)
        self.pushButton_2.clicked.connect(self.select_image)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 30))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "在线聊天系统"))
        self.checkBox.setText(_translate("MainWindow", "服务端"))
        self.checkBox_2.setText(_translate("MainWindow", "客户端"))
        self.pushButton_4.setText(_translate("MainWindow", "建立服务器"))
        self.pushButton_3.setText(_translate("MainWindow", "连接服务器"))
        self.pushButton.setText(_translate("MainWindow", "发送"))
        self.pushButton_2.setText(_translate("MainWindow", "选择发送图片"))

    def select_image(self):
        fname, _ = QFileDialog.getOpenFileName(self, '选择图片', '', 'Image Files(*.jpg *.png)')
        self.lineEdit.setPixmap(QPixmap(fname))

    # 单选按钮切换函数
    def radiobtnChange(self, status):
        if status:
            self.pushButton_3.setEnabled(False)
            self.pushButton_4.setEnabled(True)
        else:
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(False)

    # 状态栏情况发送函数
    def sendInfo(self):
        if self.pc == None:
            self.statusBar.showMessage("sned info field case out connected!!")
        else:
            info = self.lineEdit.text()
            if info != "":
                info = self.pc.hostName + ":\n" + info
                self.pc.btnsend(info)
            else:
                self.statusBar.showMessage("input can't be none!")

    # 设定本主机为服务器
    def setServer(self):
        self.pc = Server(self, "127.0.0.1", "服务管理员", int(9999))
        print('建立成功')
    # 设定本主机为客户端
    def setClient(self):
        self.pc = Client(self, "127.0.0.1" , "匿名用户", int(9999))
        print('连接成功')

# 服务端
class Server():
    def __init__(self, widget, ip, host, port):
        # 设定本主机的一些基本信息 ---------------------------------------
        self.widget = widget
        self.ip = ip  # 获得该主机ip
        self.hostName = host  # 获得该主机名
        self.port = port  # 设定默认端口号(服务器端口号和客户端接入端口号都是这个默认端口)
        self.serverDict = {}  # 服务线程字典
        self.serverID = 0  # 初始的服务线程id

        self.buildSocket()

    # 创建网络连接实例
    def buildSocket(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # socket.AF_INET(!!INET - IPv4  INET6 - IPv6)
        # socket.SOCK_STREAM - 传输控制协议(TCP)
        self.initialServer()

    # 初始化服务(仅限服务器)
    def initialServer(self):
        # 首先绑定服务端口号
        self.socket.bind((self.ip, self.port))  # 绑定端口与主机名
        self.socket.listen(5)  # 设定最大连接数

        self.buildServer()  # 初始化一个服务线程

    # 创建服务线程
    def buildServer(self):
        server = ServerThread(str(self.serverID), self.socket)
        self.serverDict[str(self.serverID)] = server
        self.serverID += 1
        server._flag.connect(self.getFlag)
        server._signal.connect(self.getMessage)
        server._text.connect(self.getText)
        server.start()

    # 广播所有消息
    def bordCastInfo(self, info):
        print(len(self.serverDict))
        for client in self.serverDict:
            try:
                if self.serverDict[client].clientsocket != None:
                    print("尝试将信息广播出去")
                    self.serverDict[client].sendToClient(info)  # 将消息传入指定的客户端
                    print("广播成功")
            except Exception as reason:
                self.getFlag("@@@".join([client, "disconnect"]))  # 运行函数,停止某个客户端的监听(相当于关闭)
                print("服务端", reason)

    def btnsend(self, text):
        self.widget.textBrowser.append(text)
        self.bordCastInfo(text)

    # 关闭所有的服务
    def closeThread(self):
        for server in self.serverDict:
            self.serverDict[server].runflag = False

    def getFlag(self, flag):
        flag = flag.split("@@@")
        if flag[1] == "connect":  # 如果传来连接成功,则新开一个线程监听
            self.buildServer()
        elif flag[1] == "disconnect":  # 如果连接出现问题
            self.serverDict[flag[0]].runflag = False

    def getMessage(self, signal):
        signal = signal.split("@@@")
        self.widget.statusBar.showMessage("serverID " + signal[0] + " status:" + signal[1])

    def getText(self, text):
        self.widget.textBrowser.append(text)
        self.bordCastInfo(text)  # 广播出去

# 客户端
class Client():  # 主机默认为本地主机,
    def __init__(self, widget, ip, hostName, port):
        self.widget = widget
        self.ip = ip
        self.hostName = hostName  # 获得该主机名
        self.port = port  # 设定默认端口号(服务器端口号和客户端接入端口号都是这个默认端口)
        self.buildSocket()

    def buildSocket(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.buildClient()

    def buildClient(self):
        self.client = ClientThread(self.socket)  # 获取连接
        self.client._flag.connect(self.getFlag)
        self.client._signal.connect(self.getMessage)
        self.client._text.connect(self.getText)
        if self.client.connectServer(self.ip, self.port):
            self.client.start()

    def sendToServer(self, text):  # 向服务器发送消息
        try:
            self.socket.send(text.encode('utf-8'))
        except Exception as reason:
            self.getMessage(reason)
            self.getFlag("disconnect")  # 发送连接失败标志

    def btnsend(self, text):
        self.sendToServer(text)

    def closeThread(self):
        self.runflag = False

    def getFlag(self, flag):
        if flag == "connect":
            self.widget.statusBar.showMessage("connect success!!")
        elif flag == "disconnect":
            self.client.runflag = False

    def getMessage(self, signal):
        self.widget.statusBar.showMessage(signal)

    def getText(self, text):
        self.widget.textBrowser.append(text)

# 监听连接线程,负责构成会话(服务端线程)
class ServerThread(QThread):
    _signal = pyqtSignal(str)  # 设定信号,主要向主线程发送信号
    _text = pyqtSignal(str)  # 设定信号,向主线程发送接收到的信息
    _flag = pyqtSignal(str)  # 设定信号,向主线程发送连接状态标志

    def __init__(self, serverID, serverSocket):
        super(ServerThread, self).__init__()
        self.serverID = serverID  # 获得主机实例
        self.serverSocket = serverSocket
        self.clientsocket = None
        self.addr = None
        self.runflag = True

        self.connectList = ["connect", "disconnect"]  # 连接成功与连接失败

    # 自动进行该函数
    def run(self):
        self.sendMessage("Waiting for customer......")
        self.clientsocket, self.addr = self.serverSocket.accept()  # 收到客户端的连接后返回 连接控件,地址(持续监听,直到接收到执行下一个操作)
        print(self.clientsocket)
        self.sendText("Customer IP: %s" % str(self.addr) + " is linking!")
        self.sendFlag(0)  # 发送连接成功标志
        self.getMessage()

    # 持续接受消息
    def getMessage(self):
        while self.runflag:
            try:
                data = self.clientsocket.recv(1024).decode('utf-8')  # 接受到字符串并按照utf-8编译
                self.sendText(data)
            except Exception as reason:
                self.sendMessage(str(reason))
                self.sendText(str(self.addr) + " break connect...")
                self.sendFlag(1)  # 发送断开连接标志
                break
        self.clientsocket.close()
        print("线程关闭成功")

    def sendToClient(self, info):
        print(self.clientsocket)
        try:
            self.clientsocket.send(info.encode("utf-8"))
            print("广播成功")
        except Exception as reason:
            print("广播失败原因", reason)
            self.sendMessage(self.addr + " break connect...")
            self.sendFlag(1)

    # 发送状态信号函数
    def sendMessage(self, message):
        self._signal.emit("@@@".join([self.serverID, message]))

    # 发送接收到的消息信号
    def sendText(self, text):
        self._text.emit(text)

    # 发送连接状态标志
    def sendFlag(self, flagIndex):
        self._flag.emit("@@@".join([self.serverID, self.connectList[flagIndex]]))

class ClientThread(QThread):
    _signal = pyqtSignal(str)
    _text = pyqtSignal(str)
    _flag = pyqtSignal(str)

    def __init__(self, serverSocket):
        super(ClientThread, self).__init__()
        self.serverSocket = serverSocket
        self.runflag = True
        self.connectList = ["connect", "disconnect"]  # 连接成功与连接失败

    def connectServer(self, ip, port):
        try:
            self.serverSocket.connect((ip, port))
            self.sendFlag(0)  # 发送连接成功标志
            return True
        except Exception as reason:
            self.sendMessage(reason)
            self.sendFlag(1)  # 发送链接失败标志
            return reason

    def run(self):
        while self.runflag:
            try:
                msg = self.serverSocket.recv(1024).decode("utf-8")  # 接受服务端消息
                self.sendText(msg)
            except Exception as reason:
                self.sendMessage(reason)
                self.sendFlag(1)  # 发送连接失败标志
                break

    def sendMessage(self, message):
        self._signal.emit(str(message))

    def sendText(self, text):
        self._text.emit(str(text))

    def sendFlag(self, flagIndex):
        self._flag.emit(str(self.connectList[flagIndex]))